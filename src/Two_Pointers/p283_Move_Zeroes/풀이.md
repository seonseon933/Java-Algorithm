## 문제
정수 배열 nums가 주어졌을 때, 모든 0을 배열의 끝으로 이동시키되,0이 아닌 요소들의 순서는 그대로 유지해야 한다.<br>
배열을 복사하거나 새로운 배열을 만들면 안 됨.<br>

<제약조건><br>
`1 <= nums.length <= 104`
`-231 <= nums[i] <= 231 - 1`

Example 1:
```
Input: nums = [0,1,0,3,12]
Output: [1,3,12,0,0]
```
Example 2:
```
Input: nums = [0]
Output: [0]
```

### 풀이
배열을 새로 만들지 않고 처리하려면 포인터(또는 인덱스)만으로 위치를 조정해야 하니, Two Pointers를 이용해 한 번의 순회로 해결할 수 있음.

```
int p1 = 0, p2 = 0;
```
p1는 0이 아닌 숫자가 들어와야 할 위치이고, p2는 현재 검사 중인 위치이다.

```
while (p2 < nums.length) {
    if (nums[p2] != 0) {
        int tmp = nums[p1];
        nums[p1] = nums[p2];
        nums[p2] = tmp;
        p1++;
    }
    p2++;
}
```
p2는 전체 배열을 한 칸씩 검사한다.
nums[p2]가 0이 아니면 nums[p1]과 nums[p2]를 swap. p1과 p2가 같을 때도 swap은 실행되지만, 자기 자신과 바꾸므로 변화 없음.
swap을 한 후, p1과 p2 둘 다 다음 위치로 이동을 한다.

만약 nums[p2]가 0이라면 p2만 다음 위치로 이동한다.
```
ex:
Input: nums = [0,1,0,3,12]
Output: [1,3,12,0,0]

[0, 1, 0, 3, 12] p2+1 -> p2 = 1, p1 = 0
 
[1, 0, 0, 3, 12] p1, p2 swap -> p2 = 2, p1 = 1 -> 2번 0이니 p2만 +1. p2 = 3, p1 = 1

[1, 3, 0, 0, 12] p1, p2 swap

[1, 3, 12, 0, 0]
```